# CS300
In the projects for this course, I was primarily focused on understanding and implementing various data structures and algorithms. The first project involved analyzing the run-time and memory usage of different data structures, which is crucial for optimizing performance in software applications. The second project required me to sort and print a list of courses in the Computer Science program in alphanumeric order, which highlighted the importance of efficient sorting algorithms and data organization.

To tackle these problems, I began by researching the characteristics and use cases of various data structures, such as arrays, linked lists, stacks, and queues. Understanding these structures is vital because they form the backbone of efficient algorithm design. I implemented the sorting algorithm using a suitable data structure that allowed for optimal performance, ensuring that I could handle larger datasets effectively. This experience reinforced the idea that the choice of data structure can significantly impact the efficiency and scalability of a program.

Throughout the projects, I encountered several roadblocks, particularly when it came to understanding the complexities of different algorithms. For instance, I initially struggled with the time complexity analysis of sorting algorithms. To overcome this, I sought additional resources, such as online tutorials and peer discussions, which provided clarity on the concepts. Additionally, I utilized debugging tools to trace my code and identify inefficiencies, which helped me refine my approach.

Working on these projects has expanded my approach to designing software by emphasizing the importance of selecting the right data structures and algorithms for specific tasks. I learned to evaluate the trade-offs between different approaches, considering factors such as time complexity, space complexity, and ease of implementation. This analytical mindset will be invaluable in future software development endeavors.

My work on these projects has significantly evolved the way I write programs. I now prioritize writing code that is not only functional but also maintainable, readable, and adaptable. I have adopted best practices such as clear variable naming, modular design, and comprehensive documentation. These practices ensure that my code can be easily understood and modified by others, which is essential for collaborative projects and long-term maintenance.

By reflecting on these aspects, I have gained a deeper understanding of data structures and algorithms, which will undoubtedly enhance my future programming endeavors. I look forward to applying these insights in real-world applications and continuing to develop my skills in software design.
